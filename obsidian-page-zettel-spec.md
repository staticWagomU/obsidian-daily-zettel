# obsidian-page-zettel å®Ÿè£…ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## ç›®æ¬¡

1. [ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦](#1-ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦)
2. [æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯](#2-æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯)
3. [ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ](#3-ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ )
4. [å‹å®šç¾©](#4-å‹å®šç¾©)
5. [ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ](#5-ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ)
6. [ã‚µãƒ¼ãƒ“ã‚¹å±¤è¨­è¨ˆ](#6-ã‚µãƒ¼ãƒ“ã‚¹å±¤è¨­è¨ˆ)
7. [UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ](#7-uiã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ)
8. [ã‚³ãƒãƒ³ãƒ‰è¨­è¨ˆ](#8-ã‚³ãƒãƒ³ãƒ‰è¨­è¨ˆ)
9. [è¨­å®šã‚¹ã‚­ãƒ¼ãƒ](#9-è¨­å®šã‚¹ã‚­ãƒ¼ãƒ)
10. [ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå®šç¾©](#10-ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå®šç¾©)
11. [Obsidian API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](#11-obsidian-api-ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹)
12. [å®Ÿè£…æ‰‹é †](#12-å®Ÿè£…æ‰‹é †)
13. [ãƒ†ã‚¹ãƒˆè¨ˆç”»](#13-ãƒ†ã‚¹ãƒˆè¨ˆç”»)

---

## 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

### 1.1 ç›®çš„

ãƒšãƒ¼ã‚¸ã‚’èµ·ç‚¹ã¨ã—ãŸ Zettelkasten ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ Obsidian ã§å®Ÿç¾ã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€‚
**ãƒ¢ãƒã‚¤ãƒ«ãƒ¡ã‚¤ãƒ³ä½¿ç”¨**ã‚’å‰æã«ã€æœ€å°é™ã®æ“ä½œã§ãƒãƒ¼ãƒˆã®åˆ‡ã‚Šå‡ºã—ãƒ»åˆ†é¡ãƒ»æ¥ç¶šã‚’è‡ªå‹•åŒ–ã™ã‚‹ã€‚

### 1.2 è§£æ±ºã™ã‚‹èª²é¡Œ

| èª²é¡Œ | è§£æ±ºç­– |
|------|--------|
| 5ç¨®é¡ã®ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã®åˆ¤æ–­è² è· | é¸æŠè‚¢ã‚’çµã‚Šã€æ®µéšçš„æ˜‡æ ¼ãƒ¢ãƒ‡ãƒ«ã‚’æ¡ç”¨ |
| ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä»˜ä¸ã®æ‰‹é–“ | ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ãƒ»ãƒ•ã‚©ãƒ«ãƒ€é…ç½®ã‚’è‡ªå‹•åŒ– |
| ãƒãƒ¼ãƒˆé–“æ¥ç¶šã®ç®¡ç† | Structure Note ã¸ã®è‡ªå‹•ææ¡ˆ + å­¤ç«‹ãƒãƒ¼ãƒˆã®å¯è¦–åŒ– |
| ãƒ¢ãƒã‚¤ãƒ«ã§ã®æ“ä½œæ€§ | å¤§ããªã‚¿ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã€ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆæœ€é©åŒ– |

### 1.3 ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã¨é·ç§»ãƒ¢ãƒ‡ãƒ«

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Literature â”‚ ï¼ˆç‹¬ç«‹ç³»çµ±ï¼‰
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Fleeting â”‚ â†’  â”‚ Permanent â”‚ â†’  â”‚ Structure â”‚ â†’  â”‚  Index  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ä¸€æ™‚ãƒ¡ãƒ¢        åŸå­çš„çŸ¥è­˜         MOC          ãƒˆãƒƒãƒ—ç›®æ¬¡
```

---

## 2. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### 2.1 å¿…é ˆä¾å­˜

```json
{
  "devDependencies": {
    "@types/node": "^16.11.6",
    "typescript": "^5.0.0",
    "esbuild": "^0.17.0",
    "obsidian": "latest"
  }
}
```

### 2.2 é–‹ç™ºãƒ„ãƒ¼ãƒ«

| ãƒ„ãƒ¼ãƒ« | ç”¨é€” |
|--------|------|
| TypeScript | å‹å®‰å…¨ãªé–‹ç™º |
| esbuild | é«˜é€Ÿãƒãƒ³ãƒ‰ãƒ« |
| ESLint | ã‚³ãƒ¼ãƒ‰å“è³ª |
| Prettier | ã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ |

### 2.3 Obsidian API ãƒãƒ¼ã‚¸ãƒ§ãƒ³

```json
{
  "minAppVersion": "1.0.0"
}
```

---

## 3. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
obsidian-page-zettel/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts                          # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ index.ts                     # å‹ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
â”‚   â”‚   â”œâ”€â”€ note-types.ts                # ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—å®šç¾©
â”‚   â”‚   â””â”€â”€ settings.ts                  # è¨­å®šå‹å®šç¾©
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ NoteManager.ts               # ãƒãƒ¼ãƒˆä½œæˆãƒ»æ˜‡æ ¼
â”‚   â”‚   â”œâ”€â”€ FrontmatterService.ts        # ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼æ“ä½œ
â”‚   â”‚   â””â”€â”€ ConnectionManager.ts         # ãƒãƒ¼ãƒˆé–“æ¥ç¶š
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ TemplateService.ts           # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‡¦ç†
â”‚   â”‚   â”œâ”€â”€ FolderService.ts             # ãƒ•ã‚©ãƒ«ãƒ€é…ç½®
â”‚   â”‚   â”œâ”€â”€ SuggestionService.ts         # Structure ææ¡ˆ
â”‚   â”‚   â””â”€â”€ OrphanDetector.ts            # å­¤ç«‹æ¤œå‡º
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ modals/
â”‚   â”‚   â”‚   â”œâ”€â”€ NoteTypeModal.ts         # ã‚¿ã‚¤ãƒ—é¸æŠ
â”‚   â”‚   â”‚   â”œâ”€â”€ StructureSuggestModal.ts # Structure ææ¡ˆ
â”‚   â”‚   â”‚   â””â”€â”€ QuickCaptureModal.ts     # ã‚¯ã‚¤ãƒƒã‚¯å…¥åŠ›
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ views/
â”‚   â”‚       â””â”€â”€ OrphanView.ts            # å­¤ç«‹ãƒãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼
â”‚   â”‚
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ index.ts                     # ã‚³ãƒãƒ³ãƒ‰ç™»éŒ²
â”‚   â”‚   â”œâ”€â”€ ExtractSelectionCommand.ts   # é¸æŠåˆ‡ã‚Šå‡ºã—
â”‚   â”‚   â”œâ”€â”€ PromoteNoteCommand.ts        # ãƒãƒ¼ãƒˆæ˜‡æ ¼
â”‚   â”‚   â””â”€â”€ LinkToStructureCommand.ts    # Structure æ¥ç¶š
â”‚   â”‚
â”‚   â””â”€â”€ settings/
â”‚       â”œâ”€â”€ SettingsTab.ts               # è¨­å®šUI
â”‚       â””â”€â”€ defaults.ts                  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
â”‚
â”œâ”€â”€ styles.css                           # ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«
â”œâ”€â”€ manifest.json                        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆ
â”œâ”€â”€ versions.json                        # ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ esbuild.config.mjs
â””â”€â”€ .eslintrc.js
```

---

## 4. å‹å®šç¾©

### 4.1 `src/types/note-types.ts`

```typescript
/**
 * Zettelkasten ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—
 */
export type NoteType =
  | 'fleeting'
  | 'literature'
  | 'permanent'
  | 'structure'
  | 'index';

/**
 * ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã”ã¨ã®è¨­å®š
 */
export interface NoteTypeConfig {
  /** è¡¨ç¤ºãƒ©ãƒ™ãƒ« */
  label: string;
  /** æ—¥æœ¬èªãƒ©ãƒ™ãƒ« */
  labelJa: string;
  /** èª¬æ˜æ–‡ */
  description: string;
  /** ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆçµµæ–‡å­—ï¼‰ */
  icon: string;
  /** ä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€ */
  folder: string;
  /** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å */
  template: string;
}

/**
 * å…¨ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã®è¨­å®šãƒãƒƒãƒ—
 */
export const NOTE_TYPE_CONFIG: Record<NoteType, NoteTypeConfig> = {
  fleeting: {
    label: 'Fleeting Note',
    labelJa: 'ä¸€æ™‚ãƒ¡ãƒ¢',
    description: 'Quick thought or idea to process later',
    icon: 'ğŸ’­',
    folder: '10-Fleeting',
    template: 'fleeting-template.md'
  },
  literature: {
    label: 'Literature Note',
    labelJa: 'æ–‡çŒ®ãƒãƒ¼ãƒˆ',
    description: 'Notes from external sources (books, articles)',
    icon: 'ğŸ“š',
    folder: '20-Literature',
    template: 'literature-template.md'
  },
  permanent: {
    label: 'Permanent Note',
    labelJa: 'æ°¸ç¶šãƒãƒ¼ãƒˆ',
    description: 'Atomic, interconnected knowledge unit',
    icon: 'ğŸ’',
    folder: '30-Permanent',
    template: 'permanent-template.md'
  },
  structure: {
    label: 'Structure Note',
    labelJa: 'æ§‹é€ ãƒãƒ¼ãƒˆ',
    description: 'Map of Content (MOC) organizing notes',
    icon: 'ğŸ—‚ï¸',
    folder: '40-Structure',
    template: 'structure-template.md'
  },
  index: {
    label: 'Index Note',
    labelJa: 'ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹',
    description: 'Top-level entry point',
    icon: 'ğŸ“‹',
    folder: '50-Index',
    template: 'index-template.md'
  }
};

/**
 * æ˜‡æ ¼ãƒ‘ã‚¹å®šç¾©
 * ã‚­ãƒ¼: å…ƒã®ã‚¿ã‚¤ãƒ—, å€¤: æ˜‡æ ¼å¯èƒ½ãªã‚¿ã‚¤ãƒ—ã®é…åˆ—
 */
export const PROMOTION_PATHS: Record<NoteType, NoteType[]> = {
  fleeting: ['permanent'],
  literature: [],  // Literature ã¯ç‹¬ç«‹ï¼ˆæ˜‡æ ¼ãªã—ï¼‰
  permanent: ['structure'],
  structure: ['index'],
  index: []
};

/**
 * ãƒãƒ¼ãƒˆã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ï¼‰
 */
export interface NoteMetadata {
  type: NoteType;
  created: string;  // ISO 8601
  tags: string[];

  // ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«
  source_notes?: string[];      // å…ƒãƒãƒ¼ãƒˆã¸ã®ãƒªãƒ³ã‚¯
  structure_notes?: string[];   // æ‰€å± Structure Note
  status?: NoteStatus;
  promoted_from?: NoteType;
  promoted_at?: string;

  // Literature å›ºæœ‰
  source_type?: 'book' | 'article' | 'video' | 'podcast' | 'other';
  source_title?: string;
  source_author?: string;
  source_url?: string;
}

/**
 * ãƒãƒ¼ãƒˆã®æˆç†Ÿåº¦ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
 */
export type NoteStatus = 'draft' | 'reviewed' | 'mature';
```

### 4.2 `src/types/settings.ts`

```typescript
import { NoteType } from './note-types';

/**
 * ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®š
 */
export interface PageZettelSettings {
  // ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š
  folders: FolderSettings;

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¨­å®š
  templates: TemplateSettings;

  // å‹•ä½œè¨­å®š
  behavior: BehaviorSettings;

  // UIè¨­å®š
  ui: UISettings;
}

export interface FolderSettings {
  /** ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—åˆ¥ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ */
  typeFolders: Record<NoteType, string>;
  /** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ */
  templateFolder: string;
  /** ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ */
  dailyNoteFolder: string;
}

export interface TemplateSettings {
  /** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½¿ç”¨æœ‰ç„¡ */
  useTemplates: boolean;
  /** Templater é€£æº */
  useTemplater: boolean;
}

export interface BehaviorSettings {
  /** åˆ‡ã‚Šå‡ºã—å¾Œã«å…ƒãƒãƒ¼ãƒˆã«ãƒªãƒ³ã‚¯ã‚’æŒ¿å…¥ */
  insertLinkAfterExtract: boolean;
  /** Permanent ä½œæˆæ™‚ã« Structure ææ¡ˆã‚’è¡¨ç¤º */
  suggestStructureOnPermanent: boolean;
  /** æ˜‡æ ¼æ™‚ã«è‡ªå‹•ã§ãƒ•ã‚©ãƒ«ãƒ€ç§»å‹• */
  moveOnPromotion: boolean;
  /** ãƒ•ã‚¡ã‚¤ãƒ«åã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹å½¢å¼ */
  fileNamePrefix: 'date' | 'zettel-id' | 'none';
}

export interface UISettings {
  /** ã‚³ãƒãƒ³ãƒ‰ã«çµµæ–‡å­—ã‚’è¡¨ç¤º */
  showEmojiInCommands: boolean;
  /** ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–UI */
  mobileOptimized: boolean;
}
```

---

## 5. ã‚³ã‚¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ

### 5.1 `src/core/NoteManager.ts`

```typescript
import { App, TFile, TFolder, Notice } from 'obsidian';
import {
  NoteType,
  NoteMetadata,
  NOTE_TYPE_CONFIG,
  PROMOTION_PATHS
} from '../types/note-types';
import { PageZettelSettings } from '../types/settings';
import { FrontmatterService } from './FrontmatterService';
import { TemplateService } from '../services/TemplateService';
import { FolderService } from '../services/FolderService';

export interface CreateNoteOptions {
  title: string;
  type: NoteType;
  content?: string;
  sourceFile?: TFile;
  additionalMetadata?: Partial<NoteMetadata>;
}

export interface PromoteNoteResult {
  success: boolean;
  newType?: NoteType;
  error?: string;
}

export class NoteManager {
  private app: App;
  private settings: PageZettelSettings;
  private frontmatterService: FrontmatterService;
  private templateService: TemplateService;
  private folderService: FolderService;

  constructor(app: App, settings: PageZettelSettings) {
    this.app = app;
    this.settings = settings;
    this.frontmatterService = new FrontmatterService(app);
    this.templateService = new TemplateService(app, settings);
    this.folderService = new FolderService(app, settings);
  }

  /**
   * æ–°è¦ãƒãƒ¼ãƒˆã‚’ä½œæˆ
   */
  async createNote(options: CreateNoteOptions): Promise<TFile> {
    const { title, type, content = '', sourceFile, additionalMetadata } = options;

    // 1. ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç¢ºä¿
    const folderPath = await this.folderService.ensureFolderExists(type);

    // 2. ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
    const fileName = this.generateFileName(title);
    const filePath = `${folderPath}/${fileName}`;

    // 3. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—ãƒ»å‡¦ç†
    const templateContent = await this.templateService.getProcessedTemplate(type, {
      title,
      content,
      date: new Date().toISOString(),
    });

    // 4. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
    const metadata: NoteMetadata = {
      type,
      created: new Date().toISOString(),
      tags: [type],
      ...additionalMetadata,
    };

    if (sourceFile) {
      metadata.source_notes = [`[[${sourceFile.basename}]]`];
    }

    // 5. ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ + ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’çµåˆ
    const finalContent = this.frontmatterService.addFrontmatter(
      templateContent || content,
      metadata
    );

    // 6. ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
    const file = await this.app.vault.create(filePath, finalContent);

    new Notice(`âœ… Created ${NOTE_TYPE_CONFIG[type].icon} ${title}`);

    return file;
  }

  /**
   * ãƒãƒ¼ãƒˆã‚’æ˜‡æ ¼
   */
  async promoteNote(file: TFile, targetType: NoteType): Promise<PromoteNoteResult> {
    // 1. ç¾åœ¨ã®ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
    const currentType = await this.frontmatterService.getNoteType(file);

    if (!currentType) {
      return { success: false, error: 'Cannot determine current note type' };
    }

    // 2. æ˜‡æ ¼å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    if (!this.canPromote(currentType, targetType)) {
      return {
        success: false,
        error: `Cannot promote from ${currentType} to ${targetType}`
      };
    }

    // 3. ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã‚’æ›´æ–°
    await this.frontmatterService.updateMetadata(file, {
      type: targetType,
      promoted_from: currentType,
      promoted_at: new Date().toISOString(),
    });

    // 4. ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç§»å‹•ï¼ˆè¨­å®šã§æœ‰åŠ¹ãªå ´åˆï¼‰
    if (this.settings.behavior.moveOnPromotion) {
      await this.moveToTypeFolder(file, targetType);
    }

    // 5. ã‚¿ã‚°ã‚’æ›´æ–°
    await this.frontmatterService.updateTags(file, [currentType], [targetType]);

    new Notice(`â¬†ï¸ Promoted to ${NOTE_TYPE_CONFIG[targetType].icon} ${targetType}`);

    return { success: true, newType: targetType };
  }

  /**
   * æ˜‡æ ¼å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
   */
  canPromote(from: NoteType, to: NoteType): boolean {
    return PROMOTION_PATHS[from]?.includes(to) ?? false;
  }

  /**
   * æ˜‡æ ¼å¯èƒ½ãªã‚¿ã‚¤ãƒ—ã‚’å–å¾—
   */
  getPromotionTargets(from: NoteType): NoteType[] {
    return PROMOTION_PATHS[from] || [];
  }

  /**
   * ãƒãƒ¼ãƒˆã‚’ã‚¿ã‚¤ãƒ—åˆ¥ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•
   */
  private async moveToTypeFolder(file: TFile, type: NoteType): Promise<void> {
    const targetFolder = await this.folderService.ensureFolderExists(type);
    const newPath = `${targetFolder}/${file.name}`;

    if (file.path !== newPath) {
      await this.app.fileManager.renameFile(file, newPath);
    }
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
   */
  private generateFileName(title: string): string {
    const sanitizedTitle = title.replace(/[\\/:*?"<>|]/g, '-').trim();

    switch (this.settings.behavior.fileNamePrefix) {
      case 'date':
        const datePrefix = new Date().toISOString().slice(0, 10);
        return `${datePrefix}-${sanitizedTitle}.md`;
      case 'zettel-id':
        const zettelId = new Date().toISOString()
          .replace(/[-:T]/g, '')
          .slice(0, 14);
        return `${zettelId}-${sanitizedTitle}.md`;
      case 'none':
      default:
        return `${sanitizedTitle}.md`;
    }
  }
}
```

### 5.2 `src/core/FrontmatterService.ts`

```typescript
import { App, TFile, parseYaml, stringifyYaml } from 'obsidian';
import { NoteType, NoteMetadata } from '../types/note-types';

export class FrontmatterService {
  private app: App;

  constructor(app: App) {
    this.app = app;
  }

  /**
   * ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã‚’å–å¾—
   */
  async getNoteType(file: TFile): Promise<NoteType | null> {
    const cache = this.app.metadataCache.getFileCache(file);
    return (cache?.frontmatter?.type as NoteType) || null;
  }

  /**
   * ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã‹ã‚‰ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  async getMetadata(file: TFile): Promise<Partial<NoteMetadata>> {
    const cache = this.app.metadataCache.getFileCache(file);
    return cache?.frontmatter || {};
  }

  /**
   * ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã‚’è¿½åŠ 
   */
  addFrontmatter(content: string, metadata: NoteMetadata): string {
    const yaml = stringifyYaml(metadata);
    return `---\n${yaml}---\n\n${content}`;
  }

  /**
   * ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
   */
  async updateMetadata(
    file: TFile,
    updates: Partial<NoteMetadata>
  ): Promise<void> {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      Object.assign(frontmatter, updates);
    });
  }

  /**
   * ã‚¿ã‚°ã‚’æ›´æ–°ï¼ˆå‰Šé™¤ã¨è¿½åŠ ï¼‰
   */
  async updateTags(
    file: TFile,
    tagsToRemove: string[],
    tagsToAdd: string[]
  ): Promise<void> {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      const currentTags: string[] = frontmatter.tags || [];

      // å‰Šé™¤
      const filtered = currentTags.filter(t => !tagsToRemove.includes(t));

      // è¿½åŠ ï¼ˆé‡è¤‡ãªã—ï¼‰
      const newTags = [...new Set([...filtered, ...tagsToAdd])];

      frontmatter.tags = newTags;
    });
  }

  /**
   * Structure Note ã¸ã®ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
   */
  async addStructureLink(
    file: TFile,
    structureNote: TFile
  ): Promise<void> {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      const links: string[] = frontmatter.structure_notes || [];
      const newLink = `[[${structureNote.basename}]]`;

      if (!links.includes(newLink)) {
        links.push(newLink);
        frontmatter.structure_notes = links;
      }
    });
  }
}
```

### 5.3 `src/core/ConnectionManager.ts`

```typescript
import { App, TFile } from 'obsidian';
import { FrontmatterService } from './FrontmatterService';

export class ConnectionManager {
  private app: App;
  private frontmatterService: FrontmatterService;

  constructor(app: App) {
    this.app = app;
    this.frontmatterService = new FrontmatterService(app);
  }

  /**
   * Permanent Note ã‚’ Structure Note ã«æ¥ç¶š
   */
  async linkPermanentToStructure(
    permanentNote: TFile,
    structureNote: TFile
  ): Promise<void> {
    // 1. Permanent Note ã®ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã‚’æ›´æ–°
    await this.frontmatterService.addStructureLink(permanentNote, structureNote);

    // 2. Structure Note ã«ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
    await this.appendLinkToStructure(structureNote, permanentNote);
  }

  /**
   * Structure Note ã®æœ¬æ–‡ã«ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
   */
  private async appendLinkToStructure(
    structureNote: TFile,
    targetNote: TFile
  ): Promise<void> {
    const content = await this.app.vault.read(structureNote);
    const link = `- [[${targetNote.basename}]]`;

    // æ—¢ã«ãƒªãƒ³ã‚¯ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (content.includes(`[[${targetNote.basename}]]`)) {
      return;
    }

    // "## é–¢é€£ãƒãƒ¼ãƒˆ" ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ¢ã—ã¦è¿½åŠ 
    const sectionRegex = /^## (é–¢é€£ãƒãƒ¼ãƒˆ|Related Notes|Notes)/m;
    const match = content.match(sectionRegex);

    let newContent: string;
    if (match && match.index !== undefined) {
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æ¬¡ã®è¡Œã«è¿½åŠ 
      const insertPos = content.indexOf('\n', match.index) + 1;
      newContent =
        content.slice(0, insertPos) +
        link + '\n' +
        content.slice(insertPos);
    } else {
      // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒãªã‘ã‚Œã°æœ«å°¾ã«è¿½åŠ 
      newContent = content + `\n\n## é–¢é€£ãƒãƒ¼ãƒˆ\n\n${link}\n`;
    }

    await this.app.vault.modify(structureNote, newContent);
  }

  /**
   * ãƒãƒ¼ãƒˆã®æ¥ç¶šçŠ¶æ³ã‚’å–å¾—
   */
  async getConnections(file: TFile): Promise<{
    incoming: TFile[];
    outgoing: TFile[];
    structureNotes: TFile[];
  }> {
    const cache = this.app.metadataCache.getFileCache(file);
    const result = {
      incoming: [] as TFile[],
      outgoing: [] as TFile[],
      structureNotes: [] as TFile[],
    };

    // ç™ºä¿¡ãƒªãƒ³ã‚¯
    if (cache?.links) {
      for (const link of cache.links) {
        const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
          link.link,
          file.path
        );
        if (linkedFile) {
          result.outgoing.push(linkedFile);
        }
      }
    }

    // ç€ä¿¡ãƒªãƒ³ã‚¯ï¼ˆbacklinksï¼‰
    // @ts-ignore - Obsidian ã®å†…éƒ¨ API
    const backlinks = this.app.metadataCache.getBacklinksForFile(file);
    if (backlinks?.data) {
      for (const [path] of backlinks.data) {
        const linkedFile = this.app.vault.getAbstractFileByPath(path);
        if (linkedFile instanceof TFile) {
          result.incoming.push(linkedFile);
        }
      }
    }

    // Structure Notes
    const structureLinks = cache?.frontmatter?.structure_notes || [];
    for (const linkStr of structureLinks) {
      const basename = linkStr.replace(/^\[\[|\]\]$/g, '');
      const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
        basename,
        file.path
      );
      if (linkedFile) {
        result.structureNotes.push(linkedFile);
      }
    }

    return result;
  }
}
```

---

## 6. ã‚µãƒ¼ãƒ“ã‚¹å±¤è¨­è¨ˆ

### 6.1 `src/services/TemplateService.ts`

```typescript
import { App, TFile } from 'obsidian';
import { NoteType, NOTE_TYPE_CONFIG } from '../types/note-types';
import { PageZettelSettings } from '../types/settings';

export interface TemplateVariables {
  title: string;
  content?: string;
  date: string;
  [key: string]: string | undefined;
}

export class TemplateService {
  private app: App;
  private settings: PageZettelSettings;

  constructor(app: App, settings: PageZettelSettings) {
    this.app = app;
    this.settings = settings;
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—ã—ã¦å¤‰æ•°ã‚’å±•é–‹
   */
  async getProcessedTemplate(
    type: NoteType,
    variables: TemplateVariables
  ): Promise<string> {
    if (!this.settings.templates.useTemplates) {
      return variables.content || '';
    }

    const templateContent = await this.loadTemplate(type);

    if (!templateContent) {
      return variables.content || '';
    }

    return this.processVariables(templateContent, variables);
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
   */
  private async loadTemplate(type: NoteType): Promise<string | null> {
    const templateFileName = NOTE_TYPE_CONFIG[type].template;
    const templatePath = `${this.settings.folders.templateFolder}/${templateFileName}`;

    const file = this.app.vault.getAbstractFileByPath(templatePath);

    if (!(file instanceof TFile)) {
      return null;
    }

    return await this.app.vault.read(file);
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ•°ã‚’å±•é–‹
   */
  private processVariables(
    template: string,
    variables: TemplateVariables
  ): string {
    let result = template;

    // {{variable}} å½¢å¼ã®ç½®æ›
    for (const [key, value] of Object.entries(variables)) {
      if (value !== undefined) {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        result = result.replace(regex, value);
      }
    }

    // æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ {{date:FORMAT}}
    result = result.replace(
      /\{\{date:([^}]+)\}\}/g,
      (_, format) => this.formatDate(new Date(), format)
    );

    return result;
  }

  /**
   * æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
   */
  private formatDate(date: Date, format: string): string {
    const pad = (n: number) => n.toString().padStart(2, '0');

    return format
      .replace('YYYY', date.getFullYear().toString())
      .replace('MM', pad(date.getMonth() + 1))
      .replace('DD', pad(date.getDate()))
      .replace('HH', pad(date.getHours()))
      .replace('mm', pad(date.getMinutes()))
      .replace('ss', pad(date.getSeconds()));
  }
}
```

### 6.2 `src/services/FolderService.ts`

```typescript
import { App, TFolder } from 'obsidian';
import { NoteType, NOTE_TYPE_CONFIG } from '../types/note-types';
import { PageZettelSettings } from '../types/settings';

export class FolderService {
  private app: App;
  private settings: PageZettelSettings;

  constructor(app: App, settings: PageZettelSettings) {
    this.app = app;
    this.settings = settings;
  }

  /**
   * ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã«å¯¾å¿œã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã‚’å–å¾—
   */
  getFolderPath(type: NoteType): string {
    return this.settings.folders.typeFolders[type] ||
           NOTE_TYPE_CONFIG[type].folder;
  }

  /**
   * ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€ãªã‘ã‚Œã°ä½œæˆ
   */
  async ensureFolderExists(type: NoteType): Promise<string> {
    const folderPath = this.getFolderPath(type);

    const existing = this.app.vault.getAbstractFileByPath(folderPath);

    if (!existing) {
      await this.app.vault.createFolder(folderPath);
    }

    return folderPath;
  }

  /**
   * å…¨ã¦ã®ã‚¿ã‚¤ãƒ—ãƒ•ã‚©ãƒ«ãƒ€ã‚’åˆæœŸåŒ–
   */
  async initializeAllFolders(): Promise<void> {
    const types: NoteType[] = [
      'fleeting', 'literature', 'permanent', 'structure', 'index'
    ];

    for (const type of types) {
      await this.ensureFolderExists(type);
    }

    // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚‚ä½œæˆ
    const templateFolder = this.settings.folders.templateFolder;
    const existing = this.app.vault.getAbstractFileByPath(templateFolder);
    if (!existing) {
      await this.app.vault.createFolder(templateFolder);
    }
  }
}
```

### 6.3 `src/services/SuggestionService.ts`

```typescript
import { App, TFile, CachedMetadata } from 'obsidian';
import { PageZettelSettings } from '../types/settings';

export interface SuggestionScore {
  file: TFile;
  score: number;
  reasons: string[];
}

export class SuggestionService {
  private app: App;
  private settings: PageZettelSettings;

  constructor(app: App, settings: PageZettelSettings) {
    this.app = app;
    this.settings = settings;
  }

  /**
   * Permanent Note ã«é–¢é€£ã™ã‚‹ Structure Notes ã‚’ææ¡ˆ
   */
  async suggestStructureNotes(
    permanentNote: TFile,
    limit: number = 5
  ): Promise<TFile[]> {
    const structureNotes = this.getAllStructureNotes();
    const permanentMeta = this.app.metadataCache.getFileCache(permanentNote);
    const permanentTags = this.extractTags(permanentMeta);
    const permanentTitle = permanentNote.basename.toLowerCase();

    const scored: SuggestionScore[] = [];

    for (const structureNote of structureNotes) {
      const score = this.calculateScore(
        structureNote,
        permanentTags,
        permanentTitle
      );

      if (score.score > 0) {
        scored.push(score);
      }
    }

    // ã‚¹ã‚³ã‚¢é™é †ã§ã‚½ãƒ¼ãƒˆ
    scored.sort((a, b) => b.score - a.score);

    return scored.slice(0, limit).map(s => s.file);
  }

  /**
   * å…¨ã¦ã® Structure Notes ã‚’å–å¾—
   */
  private getAllStructureNotes(): TFile[] {
    const structureFolder = this.settings.folders.typeFolders.structure;

    return this.app.vault.getMarkdownFiles().filter(file => {
      // ãƒ•ã‚©ãƒ«ãƒ€ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚£ãƒ«ã‚¿
      if (file.path.startsWith(structureFolder)) {
        return true;
      }

      // ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚£ãƒ«ã‚¿
      const cache = this.app.metadataCache.getFileCache(file);
      return cache?.frontmatter?.type === 'structure';
    });
  }

  /**
   * ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
   */
  private calculateScore(
    structureNote: TFile,
    targetTags: string[],
    targetTitle: string
  ): SuggestionScore {
    let score = 0;
    const reasons: string[] = [];

    const structureMeta = this.app.metadataCache.getFileCache(structureNote);
    const structureTags = this.extractTags(structureMeta);
    const structureTitle = structureNote.basename.toLowerCase();

    // ã‚¿ã‚°ã®ä¸€è‡´ï¼ˆå„10ç‚¹ï¼‰
    for (const tag of targetTags) {
      if (structureTags.includes(tag)) {
        score += 10;
        reasons.push(`Tag match: ${tag}`);
      }
    }

    // ã‚¿ã‚¤ãƒˆãƒ«ã®å˜èªãƒãƒƒãƒï¼ˆå„5ç‚¹ï¼‰
    const targetWords = targetTitle.split(/[\s-_]+/).filter(w => w.length > 2);
    const structureWords = structureTitle.split(/[\s-_]+/).filter(w => w.length > 2);

    for (const word of targetWords) {
      if (structureWords.some(sw => sw.includes(word) || word.includes(sw))) {
        score += 5;
        reasons.push(`Title word match: ${word}`);
      }
    }

    // æ—¢å­˜ã®ãƒªãƒ³ã‚¯é–¢ä¿‚ï¼ˆ20ç‚¹ï¼‰
    if (structureMeta?.links) {
      const hasLink = structureMeta.links.some(
        link => link.link.toLowerCase() === targetTitle
      );
      if (hasLink) {
        score += 20;
        reasons.push('Already linked');
      }
    }

    return { file: structureNote, score, reasons };
  }

  /**
   * ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ã‚°ã‚’æŠ½å‡º
   */
  private extractTags(meta: CachedMetadata | null): string[] {
    if (!meta) return [];

    const frontmatterTags = meta.frontmatter?.tags || [];
    const inlineTags = meta.tags?.map(t => t.tag.replace('#', '')) || [];

    return [...new Set([...frontmatterTags, ...inlineTags])];
  }
}
```

### 6.4 `src/services/OrphanDetector.ts`

```typescript
import { App, TFile } from 'obsidian';
import { PageZettelSettings } from '../types/settings';

export interface OrphanStats {
  total: number;
  orphans: TFile[];
  connected: TFile[];
}

export class OrphanDetector {
  private app: App;
  private settings: PageZettelSettings;

  constructor(app: App, settings: PageZettelSettings) {
    this.app = app;
    this.settings = settings;
  }

  /**
   * å­¤ç«‹ã—ãŸ Permanent Notes ã‚’æ¤œå‡º
   * å­¤ç«‹ = structure_notes ãŒç©ºã¾ãŸã¯æœªå®šç¾©
   */
  async detectOrphanPermanentNotes(): Promise<TFile[]> {
    const permanentFolder = this.settings.folders.typeFolders.permanent;
    const permanentNotes = this.app.vault.getMarkdownFiles().filter(file => {
      // ãƒ•ã‚©ãƒ«ãƒ€ãƒ™ãƒ¼ã‚¹ã¾ãŸã¯ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ãƒ™ãƒ¼ã‚¹
      if (file.path.startsWith(permanentFolder)) {
        return true;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      return cache?.frontmatter?.type === 'permanent';
    });

    const orphans: TFile[] = [];

    for (const file of permanentNotes) {
      const isOrphan = await this.isOrphan(file);
      if (isOrphan) {
        orphans.push(file);
      }
    }

    // ä½œæˆæ—¥æ™‚ã®æ–°ã—ã„é †ã«ã‚½ãƒ¼ãƒˆ
    orphans.sort((a, b) => b.stat.ctime - a.stat.ctime);

    return orphans;
  }

  /**
   * ãƒãƒ¼ãƒˆãŒå­¤ç«‹ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   */
  private async isOrphan(file: TFile): Promise<boolean> {
    const cache = this.app.metadataCache.getFileCache(file);
    const structureNotes = cache?.frontmatter?.structure_notes;

    // structure_notes ãŒå­˜åœ¨ã—ãªã„ or ç©ºé…åˆ— or ç©ºæ–‡å­—åˆ—
    if (!structureNotes) return true;
    if (Array.isArray(structureNotes) && structureNotes.length === 0) return true;
    if (typeof structureNotes === 'string' && structureNotes.trim() === '') return true;

    return false;
  }

  /**
   * çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
   */
  async getStats(): Promise<OrphanStats> {
    const orphans = await this.detectOrphanPermanentNotes();
    const permanentFolder = this.settings.folders.typeFolders.permanent;

    const allPermanent = this.app.vault.getMarkdownFiles().filter(file => {
      if (file.path.startsWith(permanentFolder)) return true;
      const cache = this.app.metadataCache.getFileCache(file);
      return cache?.frontmatter?.type === 'permanent';
    });

    const connected = allPermanent.filter(f => !orphans.includes(f));

    return {
      total: allPermanent.length,
      orphans,
      connected,
    };
  }
}
```

---

## 7. UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

### 7.1 `src/ui/modals/NoteTypeModal.ts`

```typescript
import { App, FuzzySuggestModal } from 'obsidian';
import { NoteType, NOTE_TYPE_CONFIG, NoteTypeConfig } from '../../types/note-types';

interface NoteTypeOption {
  type: NoteType;
  config: NoteTypeConfig;
}

export class NoteTypeModal extends FuzzySuggestModal<NoteTypeOption> {
  private onSelect: (type: NoteType) => void;
  private allowedTypes: NoteType[];

  constructor(
    app: App,
    onSelect: (type: NoteType) => void,
    allowedTypes?: NoteType[]
  ) {
    super(app);
    this.onSelect = onSelect;
    this.allowedTypes = allowedTypes ?? ['fleeting', 'literature', 'permanent'];

    this.setPlaceholder('ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã‚’é¸æŠ...');

    // ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ: ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚µã‚¤ã‚ºèª¿æ•´
    this.modalEl.addClass('page-zettel-modal');
  }

  getItems(): NoteTypeOption[] {
    return this.allowedTypes.map(type => ({
      type,
      config: NOTE_TYPE_CONFIG[type],
    }));
  }

  getItemText(item: NoteTypeOption): string {
    return `${item.config.icon} ${item.config.label}`;
  }

  renderSuggestion(item: { item: NoteTypeOption }, el: HTMLElement): void {
    const option = item.item;

    el.addClass('page-zettel-type-option');

    const container = el.createDiv({ cls: 'page-zettel-type-container' });

    // ã‚¢ã‚¤ã‚³ãƒ³
    container.createSpan({
      text: option.config.icon,
      cls: 'page-zettel-type-icon'
    });

    // ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†
    const textContainer = container.createDiv({ cls: 'page-zettel-type-text' });

    // ãƒ©ãƒ™ãƒ«
    textContainer.createDiv({
      text: option.config.label,
      cls: 'page-zettel-type-label'
    });

    // èª¬æ˜
    textContainer.createDiv({
      text: option.config.description,
      cls: 'page-zettel-type-description'
    });
  }

  onChooseItem(item: NoteTypeOption): void {
    this.onSelect(item.type);
  }
}
```

### 7.2 `src/ui/modals/StructureSuggestModal.ts`

```typescript
import { App, FuzzySuggestModal, TFile, Notice } from 'obsidian';
import { SuggestionService } from '../../services/SuggestionService';
import { PageZettelSettings } from '../../types/settings';

interface StructureOption {
  file: TFile | null;
  label: string;
  isSkip: boolean;
}

export class StructureSuggestModal extends FuzzySuggestModal<StructureOption> {
  private permanentNote: TFile;
  private onSelect: (file: TFile | null) => void;
  private suggestionService: SuggestionService;
  private suggestions: TFile[] = [];

  constructor(
    app: App,
    settings: PageZettelSettings,
    permanentNote: TFile,
    onSelect: (file: TFile | null) => void
  ) {
    super(app);
    this.permanentNote = permanentNote;
    this.onSelect = onSelect;
    this.suggestionService = new SuggestionService(app, settings);

    this.setPlaceholder('Structure Note ã‚’é¸æŠï¼ˆã¾ãŸã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰...');
    this.modalEl.addClass('page-zettel-modal');

    // ææ¡ˆã‚’éåŒæœŸã§èª­ã¿è¾¼ã¿
    this.loadSuggestions();
  }

  private async loadSuggestions(): Promise<void> {
    this.suggestions = await this.suggestionService.suggestStructureNotes(
      this.permanentNote,
      10
    );
    // å†æç”»ã‚’ãƒˆãƒªã‚¬ãƒ¼
    this.inputEl.dispatchEvent(new Event('input'));
  }

  getItems(): StructureOption[] {
    const options: StructureOption[] = [];

    // ã‚¹ã‚­ãƒƒãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æœ€åˆã«
    options.push({
      file: null,
      label: 'â­ï¸ ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå¾Œã§æ¥ç¶šï¼‰',
      isSkip: true,
    });

    // ææ¡ˆã•ã‚ŒãŸ Structure Notes
    for (const file of this.suggestions) {
      options.push({
        file,
        label: file.basename,
        isSkip: false,
      });
    }

    return options;
  }

  getItemText(item: StructureOption): string {
    return item.label;
  }

  renderSuggestion(item: { item: StructureOption }, el: HTMLElement): void {
    const option = item.item;

    el.addClass('page-zettel-structure-option');

    if (option.isSkip) {
      el.addClass('page-zettel-skip-option');
      el.createSpan({ text: option.label });
    } else {
      el.createSpan({ text: 'ğŸ—‚ï¸ ', cls: 'page-zettel-structure-icon' });
      el.createSpan({ text: option.label });
    }
  }

  onChooseItem(item: StructureOption): void {
    if (item.isSkip) {
      new Notice('ğŸ“ å¾Œã§ Structure Note ã«æ¥ç¶šã§ãã¾ã™');
      this.onSelect(null);
    } else {
      this.onSelect(item.file);
    }
  }
}
```

### 7.3 `src/ui/views/OrphanView.ts`

```typescript
import { ItemView, WorkspaceLeaf, TFile } from 'obsidian';
import PageZettelPlugin from '../../main';
import { OrphanDetector } from '../../services/OrphanDetector';

export const VIEW_TYPE_ORPHAN = 'page-zettel-orphan-view';

export class OrphanView extends ItemView {
  private plugin: PageZettelPlugin;
  private orphanDetector: OrphanDetector;

  constructor(leaf: WorkspaceLeaf, plugin: PageZettelPlugin) {
    super(leaf);
    this.plugin = plugin;
    this.orphanDetector = new OrphanDetector(
      plugin.app,
      plugin.settings
    );
  }

  getViewType(): string {
    return VIEW_TYPE_ORPHAN;
  }

  getDisplayText(): string {
    return 'å­¤ç«‹ Permanent Notes';
  }

  getIcon(): string {
    return 'unlink';
  }

  async onOpen(): Promise<void> {
    await this.render();
  }

  async render(): Promise<void> {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass('page-zettel-orphan-view');

    // ãƒ˜ãƒƒãƒ€ãƒ¼
    const header = container.createDiv({ cls: 'page-zettel-orphan-header' });
    header.createEl('h4', { text: 'ğŸ”— å­¤ç«‹ Permanent Notes' });

    // çµ±è¨ˆ
    const stats = await this.orphanDetector.getStats();
    const statsEl = header.createDiv({ cls: 'page-zettel-orphan-stats' });
    statsEl.createSpan({
      text: `${stats.orphans.length} / ${stats.total} ä»¶ãŒæœªæ¥ç¶š`
    });

    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒœã‚¿ãƒ³
    const refreshBtn = header.createEl('button', {
      text: 'ğŸ”„',
      cls: 'page-zettel-refresh-btn',
      attr: { 'aria-label': 'æ›´æ–°' }
    });
    refreshBtn.addEventListener('click', () => this.render());

    // ãƒªã‚¹ãƒˆ
    if (stats.orphans.length === 0) {
      container.createDiv({
        text: 'âœ… ã™ã¹ã¦ã® Permanent Notes ã¯ Structure Note ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ï¼',
        cls: 'page-zettel-orphan-empty'
      });
      return;
    }

    const list = container.createEl('ul', { cls: 'page-zettel-orphan-list' });

    for (const file of stats.orphans) {
      this.renderOrphanItem(list, file);
    }
  }

  private renderOrphanItem(list: HTMLUListElement, file: TFile): void {
    const item = list.createEl('li', { cls: 'page-zettel-orphan-item' });

    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒªãƒ³ã‚¯
    const link = item.createEl('a', {
      text: file.basename,
      cls: 'page-zettel-orphan-link'
    });
    link.addEventListener('click', (e) => {
      e.preventDefault();
      this.app.workspace.openLinkText(file.path, '');
    });

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
    const actions = item.createDiv({ cls: 'page-zettel-orphan-actions' });

    const linkBtn = actions.createEl('button', {
      text: 'ğŸ”— æ¥ç¶š',
      cls: 'page-zettel-action-btn'
    });
    linkBtn.addEventListener('click', async () => {
      await this.plugin.linkToStructure(file);
      await this.render();
    });
  }
}
```

---

## 8. ã‚³ãƒãƒ³ãƒ‰è¨­è¨ˆ

### 8.1 `src/commands/index.ts`

```typescript
import { Plugin, Editor, MarkdownView } from 'obsidian';
import { PageZettelSettings } from '../types/settings';
import { extractSelection } from './ExtractSelectionCommand';
import { promoteNote } from './PromoteNoteCommand';
import { linkToStructure } from './LinkToStructureCommand';

export function registerCommands(
  plugin: Plugin,
  settings: PageZettelSettings
): void {
  const emoji = settings.ui.showEmojiInCommands;

  // é¸æŠç¯„å›²ã‹ã‚‰æ–°è¦ãƒãƒ¼ãƒˆä½œæˆ
  plugin.addCommand({
    id: 'extract-selection',
    name: emoji ? 'ğŸ“ é¸æŠç¯„å›²ã‹ã‚‰æ–°è¦ãƒãƒ¼ãƒˆ' : 'é¸æŠç¯„å›²ã‹ã‚‰æ–°è¦ãƒãƒ¼ãƒˆ',
    editorCallback: (editor: Editor, view: MarkdownView) => {
      extractSelection(plugin, editor, view);
    },
    hotkeys: [{ modifiers: ['Mod', 'Shift'], key: 'e' }]
  });

  // ãƒãƒ¼ãƒˆæ˜‡æ ¼
  plugin.addCommand({
    id: 'promote-note',
    name: emoji ? 'â¬†ï¸ ãƒãƒ¼ãƒˆã‚’æ˜‡æ ¼' : 'ãƒãƒ¼ãƒˆã‚’æ˜‡æ ¼',
    callback: () => promoteNote(plugin),
    hotkeys: [{ modifiers: ['Mod', 'Shift'], key: 'p' }]
  });

  // Structure Note ã«æ¥ç¶š
  plugin.addCommand({
    id: 'link-to-structure',
    name: emoji ? 'ğŸ”— Structure Note ã«æ¥ç¶š' : 'Structure Note ã«æ¥ç¶š',
    callback: () => linkToStructure(plugin)
  });

  // ã‚¯ã‚¤ãƒƒã‚¯ Fleeting ãƒãƒ¼ãƒˆ
  plugin.addCommand({
    id: 'quick-fleeting',
    name: emoji ? 'ğŸ’­ ã‚¯ã‚¤ãƒƒã‚¯ Fleeting ãƒãƒ¼ãƒˆ' : 'ã‚¯ã‚¤ãƒƒã‚¯ Fleeting ãƒãƒ¼ãƒˆ',
    callback: () => {
      // QuickCaptureModal ã‚’é–‹ã
      // plugin.openQuickCapture('fleeting');
    },
    hotkeys: [{ modifiers: ['Mod'], key: 'n' }]
  });

  // å­¤ç«‹ãƒãƒ¼ãƒˆè¡¨ç¤º
  plugin.addCommand({
    id: 'show-orphans',
    name: emoji ? 'ğŸ‘ï¸ å­¤ç«‹ãƒãƒ¼ãƒˆã‚’è¡¨ç¤º' : 'å­¤ç«‹ãƒãƒ¼ãƒˆã‚’è¡¨ç¤º',
    callback: () => {
      // OrphanView ã‚’é–‹ã
      // plugin.showOrphanView();
    }
  });
}
```

### 8.2 `src/commands/ExtractSelectionCommand.ts`

```typescript
import { Editor, MarkdownView, Notice, Plugin } from 'obsidian';
import PageZettelPlugin from '../main';
import { NoteType } from '../types/note-types';
import { NoteTypeModal } from '../ui/modals/NoteTypeModal';
import { StructureSuggestModal } from '../ui/modals/StructureSuggestModal';

export async function extractSelection(
  plugin: PageZettelPlugin,
  editor: Editor,
  view: MarkdownView
): Promise<void> {
  // 1. é¸æŠãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
  const selection = editor.getSelection();

  if (!selection || selection.trim() === '') {
    new Notice('âš ï¸ ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„');
    return;
  }

  // 2. ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã‚’é¸æŠ
  const modal = new NoteTypeModal(
    plugin.app,
    async (type: NoteType) => {
      await createNoteFromSelection(plugin, editor, selection, type);
    },
    ['fleeting', 'literature', 'permanent']  // åˆ‡ã‚Šå‡ºã—æ™‚ã®é¸æŠè‚¢
  );

  modal.open();
}

async function createNoteFromSelection(
  plugin: PageZettelPlugin,
  editor: Editor,
  selection: string,
  type: NoteType
): Promise<void> {
  // 3. ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆæœ€åˆã®è¡Œ or æœ€åˆã®20æ–‡å­—ï¼‰
  const firstLine = selection.split('\n')[0].trim();
  const title = firstLine.length > 40
    ? firstLine.slice(0, 40) + '...'
    : firstLine;

  // 4. ãƒãƒ¼ãƒˆã‚’ä½œæˆ
  const sourceFile = plugin.app.workspace.getActiveFile();

  const newFile = await plugin.noteManager.createNote({
    title,
    type,
    content: selection,
    sourceFile: sourceFile ?? undefined,
  });

  // 5. å…ƒãƒãƒ¼ãƒˆã«ãƒªãƒ³ã‚¯ã‚’æŒ¿å…¥ï¼ˆè¨­å®šã§æœ‰åŠ¹ãªå ´åˆï¼‰
  if (plugin.settings.behavior.insertLinkAfterExtract) {
    const link = `[[${newFile.basename}]]`;
    editor.replaceSelection(link);
  }

  // 6. Permanent ã®å ´åˆã¯ Structure Note ã¸ã®æ¥ç¶šã‚’ææ¡ˆ
  if (type === 'permanent' && plugin.settings.behavior.suggestStructureOnPermanent) {
    const structureModal = new StructureSuggestModal(
      plugin.app,
      plugin.settings,
      newFile,
      async (structureFile) => {
        if (structureFile) {
          await plugin.connectionManager.linkPermanentToStructure(
            newFile,
            structureFile
          );
        }
      }
    );
    structureModal.open();
  }

  // 7. æ–°è¦ãƒãƒ¼ãƒˆã‚’é–‹ã
  await plugin.app.workspace.openLinkText(newFile.path, '');
}
```

### 8.3 `src/commands/PromoteNoteCommand.ts`

```typescript
import { Notice, TFile } from 'obsidian';
import PageZettelPlugin from '../main';
import { NoteType, PROMOTION_PATHS } from '../types/note-types';
import { NoteTypeModal } from '../ui/modals/NoteTypeModal';
import { StructureSuggestModal } from '../ui/modals/StructureSuggestModal';

export async function promoteNote(plugin: PageZettelPlugin): Promise<void> {
  // 1. ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—
  const file = plugin.app.workspace.getActiveFile();

  if (!file) {
    new Notice('âš ï¸ ãƒãƒ¼ãƒˆã‚’é–‹ã„ã¦ãã ã•ã„');
    return;
  }

  // 2. ç¾åœ¨ã®ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
  const currentType = await plugin.frontmatterService.getNoteType(file);

  if (!currentType) {
    new Notice('âš ï¸ ã“ã®ãƒãƒ¼ãƒˆã«ã¯ã‚¿ã‚¤ãƒ—ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    return;
  }

  // 3. æ˜‡æ ¼å¯èƒ½ãªã‚¿ã‚¤ãƒ—ã‚’å–å¾—
  const targets = plugin.noteManager.getPromotionTargets(currentType);

  if (targets.length === 0) {
    new Notice(`â„¹ï¸ ${currentType} ã¯ã“ã‚Œä»¥ä¸Šæ˜‡æ ¼ã§ãã¾ã›ã‚“`);
    return;
  }

  // 4. æ˜‡æ ¼å…ˆã‚’é¸æŠï¼ˆè¤‡æ•°ã‚ã‚‹å ´åˆï¼‰
  if (targets.length === 1) {
    await executePromotion(plugin, file, targets[0]);
  } else {
    const modal = new NoteTypeModal(
      plugin.app,
      (targetType) => executePromotion(plugin, file, targetType),
      targets
    );
    modal.open();
  }
}

async function executePromotion(
  plugin: PageZettelPlugin,
  file: TFile,
  targetType: NoteType
): Promise<void> {
  const result = await plugin.noteManager.promoteNote(file, targetType);

  if (!result.success) {
    new Notice(`âŒ æ˜‡æ ¼å¤±æ•—: ${result.error}`);
    return;
  }

  // Permanent ã¸ã®æ˜‡æ ¼æ™‚ã¯ Structure æ¥ç¶šã‚’ææ¡ˆ
  if (targetType === 'permanent' && plugin.settings.behavior.suggestStructureOnPermanent) {
    const structureModal = new StructureSuggestModal(
      plugin.app,
      plugin.settings,
      file,
      async (structureFile) => {
        if (structureFile) {
          await plugin.connectionManager.linkPermanentToStructure(file, structureFile);
        }
      }
    );
    structureModal.open();
  }
}
```

---

## 9. è¨­å®šã‚¹ã‚­ãƒ¼ãƒ

### 9.1 `src/settings/defaults.ts`

```typescript
import { PageZettelSettings } from '../types/settings';
import { NOTE_TYPE_CONFIG, NoteType } from '../types/note-types';

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šå€¤
 */
export const DEFAULT_SETTINGS: PageZettelSettings = {
  folders: {
    typeFolders: {
      fleeting: NOTE_TYPE_CONFIG.fleeting.folder,
      literature: NOTE_TYPE_CONFIG.literature.folder,
      permanent: NOTE_TYPE_CONFIG.permanent.folder,
      structure: NOTE_TYPE_CONFIG.structure.folder,
      index: NOTE_TYPE_CONFIG.index.folder,
    },
    templateFolder: 'Templates',
    dailyNoteFolder: '00-Inbox/Daily',
  },
  templates: {
    useTemplates: true,
    useTemplater: false,
  },
  behavior: {
    insertLinkAfterExtract: true,
    suggestStructureOnPermanent: true,
    moveOnPromotion: true,
    fileNamePrefix: 'date',
  },
  ui: {
    showEmojiInCommands: true,
    mobileOptimized: true,
  },
};
```

### 9.2 `src/settings/SettingsTab.ts`

```typescript
import { App, PluginSettingTab, Setting } from 'obsidian';
import PageZettelPlugin from '../main';
import { NoteType, NOTE_TYPE_CONFIG } from '../types/note-types';

export class PageZettelSettingsTab extends PluginSettingTab {
  plugin: PageZettelPlugin;

  constructor(app: App, plugin: PageZettelPlugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    containerEl.createEl('h2', { text: 'Page Zettel è¨­å®š' });

    // =====================================
    // ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š
    // =====================================
    containerEl.createEl('h3', { text: 'ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š' });

    const noteTypes: NoteType[] = [
      'fleeting', 'literature', 'permanent', 'structure', 'index'
    ];

    for (const type of noteTypes) {
      const config = NOTE_TYPE_CONFIG[type];
      new Setting(containerEl)
        .setName(`${config.icon} ${config.label} ãƒ•ã‚©ãƒ«ãƒ€`)
        .setDesc(`${config.labelJa}ã®ä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€`)
        .addText(text => text
          .setPlaceholder(config.folder)
          .setValue(this.plugin.settings.folders.typeFolders[type])
          .onChange(async (value) => {
            this.plugin.settings.folders.typeFolders[type] = value || config.folder;
            await this.plugin.saveSettings();
          })
        );
    }

    new Setting(containerEl)
      .setName('ğŸ“„ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€')
      .setDesc('ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å…ˆ')
      .addText(text => text
        .setPlaceholder('Templates')
        .setValue(this.plugin.settings.folders.templateFolder)
        .onChange(async (value) => {
          this.plugin.settings.folders.templateFolder = value || 'Templates';
          await this.plugin.saveSettings();
        })
      );

    // =====================================
    // å‹•ä½œè¨­å®š
    // =====================================
    containerEl.createEl('h3', { text: 'âš™ï¸ å‹•ä½œè¨­å®š' });

    new Setting(containerEl)
      .setName('åˆ‡ã‚Šå‡ºã—å¾Œã«ãƒªãƒ³ã‚¯ã‚’æŒ¿å…¥')
      .setDesc('é¸æŠç¯„å›²ã‚’æ–°è¦ãƒãƒ¼ãƒˆã«åˆ‡ã‚Šå‡ºã—ãŸå¾Œã€å…ƒã®ä½ç½®ã«ãƒªãƒ³ã‚¯ã‚’æŒ¿å…¥')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.behavior.insertLinkAfterExtract)
        .onChange(async (value) => {
          this.plugin.settings.behavior.insertLinkAfterExtract = value;
          await this.plugin.saveSettings();
        })
      );

    new Setting(containerEl)
      .setName('Permanent ä½œæˆæ™‚ã« Structure ã‚’ææ¡ˆ')
      .setDesc('Permanent Note ä½œæˆæ™‚ã«é–¢é€£ã™ã‚‹ Structure Note ã‚’ææ¡ˆ')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.behavior.suggestStructureOnPermanent)
        .onChange(async (value) => {
          this.plugin.settings.behavior.suggestStructureOnPermanent = value;
          await this.plugin.saveSettings();
        })
      );

    new Setting(containerEl)
      .setName('æ˜‡æ ¼æ™‚ã«ãƒ•ã‚©ãƒ«ãƒ€ç§»å‹•')
      .setDesc('ãƒãƒ¼ãƒˆæ˜‡æ ¼æ™‚ã«å¯¾å¿œã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€ã¸è‡ªå‹•ç§»å‹•')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.behavior.moveOnPromotion)
        .onChange(async (value) => {
          this.plugin.settings.behavior.moveOnPromotion = value;
          await this.plugin.saveSettings();
        })
      );

    new Setting(containerEl)
      .setName('ãƒ•ã‚¡ã‚¤ãƒ«åãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹')
      .setDesc('æ–°è¦ãƒãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«åã«ä»˜ã‘ã‚‹ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹')
      .addDropdown(dropdown => dropdown
        .addOption('date', 'æ—¥ä»˜ (YYYY-MM-DD)')
        .addOption('zettel-id', 'Zettel ID (YYYYMMDDHHmmss)')
        .addOption('none', 'ãªã—')
        .setValue(this.plugin.settings.behavior.fileNamePrefix)
        .onChange(async (value: 'date' | 'zettel-id' | 'none') => {
          this.plugin.settings.behavior.fileNamePrefix = value;
          await this.plugin.saveSettings();
        })
      );

    // =====================================
    // UIè¨­å®š
    // =====================================
    containerEl.createEl('h3', { text: 'ğŸ¨ UIè¨­å®š' });

    new Setting(containerEl)
      .setName('ã‚³ãƒãƒ³ãƒ‰ã«çµµæ–‡å­—ã‚’è¡¨ç¤º')
      .setDesc('ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆã®ã‚³ãƒãƒ³ãƒ‰åã«çµµæ–‡å­—ã‚’è¡¨ç¤º')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.ui.showEmojiInCommands)
        .onChange(async (value) => {
          this.plugin.settings.ui.showEmojiInCommands = value;
          await this.plugin.saveSettings();
        })
      );
  }
}
```

---

## 10. ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå®šç¾©

### 10.1 `Templates/fleeting-template.md`

```markdown
# {{title}}

## ğŸ’­ æ€è€ƒãƒ»ã‚¢ã‚¤ãƒ‡ã‚¢

{{content}}

## ğŸ”— é–¢é€£ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨

-

## âœ… æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

- [ ] Permanent Note ã«æ˜‡æ ¼ã™ã‚‹
```

### 10.2 `Templates/literature-template.md`

```markdown
# {{title}}

## ğŸ“š å‡ºå…¸æƒ…å ±

- **ã‚¿ã‚¤ãƒˆãƒ«**:
- **è‘—è€…**:
- **URL/ISBN**:
- **èª­ã‚“ã æ—¥**: {{date:YYYY-MM-DD}}

## ğŸ“ è¦ç´„


## ğŸ’¡ ä¸»è¦ãªãƒã‚¤ãƒ³ãƒˆ

1.

## ğŸ“Œ å¼•ç”¨ãƒ»ãƒ¡ãƒ¢

>

## ğŸ¤” è‡ªåˆ†ã®è€ƒãˆ


## ğŸ”— é–¢é€£ã™ã‚‹ Permanent Notes

-
```

### 10.3 `Templates/permanent-template.md`

```markdown
# {{title}}

## ğŸ’ ä¸»å¼µï¼ˆ1æ–‡ã§ï¼‰


## ğŸ“– èª¬æ˜

{{content}}

## ğŸ§ª æ ¹æ‹ ãƒ»ä¾‹


## ğŸ”— é–¢é€£ãƒãƒ¼ãƒˆ

-

## ğŸ“š å‚è€ƒæ–‡çŒ®

-
```

### 10.4 `Templates/structure-template.md`

```markdown
# {{title}}

## ğŸ—‚ï¸ æ¦‚è¦


## ğŸ“‘ ä¸»è¦ãªæ¦‚å¿µ

### ã‚µãƒ–ãƒˆãƒ”ãƒƒã‚¯ 1

- [[]]

### ã‚µãƒ–ãƒˆãƒ”ãƒƒã‚¯ 2

- [[]]

## ğŸ”— é–¢é€£ã™ã‚‹ Structure Notes

-

## ğŸ“‹ ã“ã®ãƒˆãƒ”ãƒƒã‚¯ã® Permanent Notes

-
```

### 10.5 `Templates/index-template.md`

```markdown
# {{title}}

## ğŸ“‹ ä¸»è¦ãªãƒˆãƒ”ãƒƒã‚¯

### ã‚«ãƒ†ã‚´ãƒª A

- [[]]

### ã‚«ãƒ†ã‚´ãƒª B

- [[]]

## ğŸ”— Structure Notes ä¸€è¦§

-
```

---

## 11. Obsidian API ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### 11.1 ã‚ˆãä½¿ã† API

| ã‚¯ãƒ©ã‚¹/ãƒ¡ã‚½ãƒƒãƒ‰ | ç”¨é€” |
|-----------------|------|
| `App` | ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ |
| `Plugin` | ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹ |
| `TFile` | ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ |
| `TFolder` | ãƒ•ã‚©ãƒ«ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ |
| `Vault` | ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ |
| `Workspace` | ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ“ä½œ |
| `MetadataCache` | ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥ |
| `FuzzySuggestModal` | æ¤œç´¢å¯èƒ½ãªãƒ¢ãƒ¼ãƒ€ãƒ« |
| `ItemView` | ã‚«ã‚¹ã‚¿ãƒ ãƒ“ãƒ¥ãƒ¼ |
| `Notice` | é€šçŸ¥è¡¨ç¤º |

### 11.2 ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ

```typescript
// ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
await app.vault.create(path, content);

// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Š
const content = await app.vault.read(file);

// ãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°
await app.vault.modify(file, newContent);

// ãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•/ãƒªãƒãƒ¼ãƒ 
await app.fileManager.renameFile(file, newPath);

// ãƒ•ã‚©ãƒ«ãƒ€ä½œæˆ
await app.vault.createFolder(path);

// ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼æ›´æ–°
await app.fileManager.processFrontMatter(file, (fm) => {
  fm.key = value;
});
```

### 11.3 ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—

```typescript
// ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥å–å¾—
const cache = app.metadataCache.getFileCache(file);

// ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼
const frontmatter = cache?.frontmatter;

// ãƒªãƒ³ã‚¯
const links = cache?.links;

// ã‚¿ã‚°
const tags = cache?.tags;

// ãƒãƒƒã‚¯ãƒªãƒ³ã‚¯ï¼ˆå†…éƒ¨APIï¼‰
// @ts-ignore
const backlinks = app.metadataCache.getBacklinksForFile(file);
```

### 11.4 ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ“ä½œ

```typescript
// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
const file = app.workspace.getActiveFile();

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
await app.workspace.openLinkText(path, sourcePath);

// ãƒ“ãƒ¥ãƒ¼ã‚’é–‹ã
await app.workspace.getLeaf('tab').setViewState({
  type: VIEW_TYPE,
  active: true,
});
```

---

## 12. å®Ÿè£…æ‰‹é †

### Phase 1: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–ï¼ˆDay 1ï¼‰

```bash
# 1. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
mkdir obsidian-page-zettel
cd obsidian-page-zettel

# 2. npm åˆæœŸåŒ–
npm init -y

# 3. ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install --save-dev \
  typescript \
  @types/node \
  esbuild \
  obsidian

# 4. TypeScript è¨­å®š
# tsconfig.json ã‚’ä½œæˆ

# 5. esbuild è¨­å®š
# esbuild.config.mjs ã‚’ä½œæˆ

# 6. manifest.json ä½œæˆ
# versions.json ä½œæˆ
```

### Phase 1: å‹å®šç¾©ï¼ˆDay 1ï¼‰

1. `src/types/note-types.ts` ã‚’ä½œæˆ
2. `src/types/settings.ts` ã‚’ä½œæˆ
3. `src/types/index.ts` ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

### Phase 1: ã‚³ã‚¢ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆDay 2-3ï¼‰

1. `src/core/FrontmatterService.ts`
2. `src/services/FolderService.ts`
3. `src/services/TemplateService.ts`
4. `src/core/NoteManager.ts`

### Phase 1: UIï¼ˆDay 3-4ï¼‰

1. `src/ui/modals/NoteTypeModal.ts`
2. `styles.css`ï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼‰

### Phase 1: ã‚³ãƒãƒ³ãƒ‰ï¼ˆDay 4-5ï¼‰

1. `src/commands/ExtractSelectionCommand.ts`
2. `src/commands/index.ts`
3. `src/main.ts`ï¼ˆçµ±åˆï¼‰

### Phase 1: è¨­å®šï¼ˆDay 5ï¼‰

1. `src/settings/defaults.ts`
2. `src/settings/SettingsTab.ts`

### Phase 2: æ¥ç¶šç®¡ç†ï¼ˆDay 6-9ï¼‰

1. `src/core/ConnectionManager.ts`
2. `src/services/SuggestionService.ts`
3. `src/ui/modals/StructureSuggestModal.ts`
4. `src/commands/PromoteNoteCommand.ts`
5. `src/commands/LinkToStructureCommand.ts`

### Phase 3: å¯è¦–åŒ–ï¼ˆDay 10-12ï¼‰

1. `src/services/OrphanDetector.ts`
2. `src/ui/views/OrphanView.ts`
3. è¨­å®šç”»é¢ã®å……å®Ÿ

---

## 13. ãƒ†ã‚¹ãƒˆè¨ˆç”»

### 13.1 æ‰‹å‹•ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª

| ã‚·ãƒŠãƒªã‚ª | æœŸå¾…çµæœ |
|----------|----------|
| ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆã§ãƒ†ã‚­ã‚¹ãƒˆé¸æŠ â†’ Extract | NoteTypeModal ãŒè¡¨ç¤º |
| Fleeting ã‚’é¸æŠ | æ–°è¦ãƒãƒ¼ãƒˆãŒä½œæˆã•ã‚Œã€ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ä»˜ä¸ |
| ä½œæˆå¾Œã®å…ƒãƒãƒ¼ãƒˆ | ãƒªãƒ³ã‚¯ãŒæŒ¿å…¥ã•ã‚Œã¦ã„ã‚‹ |
| Permanent ã‚’é¸æŠ | Structure ææ¡ˆãƒ¢ãƒ¼ãƒ€ãƒ«ãŒè¡¨ç¤º |
| Structure ã‚’é¸æŠ | ä¸¡æ–¹ã®ãƒãƒ¼ãƒˆã«ãƒªãƒ³ã‚¯ãŒè¿½åŠ  |
| Fleeting ãƒãƒ¼ãƒˆã§ Promote | Permanent ã«æ˜‡æ ¼ã€ãƒ•ã‚©ãƒ«ãƒ€ç§»å‹• |
| å­¤ç«‹ãƒãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼ã‚’é–‹ã | æœªæ¥ç¶šã® Permanent ãŒä¸€è¦§è¡¨ç¤º |

### 13.2 ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹

| ã‚±ãƒ¼ã‚¹ | å¯¾å¿œ |
|--------|------|
| é¸æŠãƒ†ã‚­ã‚¹ãƒˆãŒç©º | Notice ã§è­¦å‘Š |
| åŒåãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ | é€£ç•ªã‚’ä»˜ä¸ |
| ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã—ãªã„ | è‡ªå‹•ä½œæˆ |
| æ˜‡æ ¼ä¸å¯èƒ½ãªã‚¿ã‚¤ãƒ— | Notice ã§é€šçŸ¥ |
| ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½¿ç”¨ |

### 13.3 ãƒ¢ãƒã‚¤ãƒ«ãƒ†ã‚¹ãƒˆ

| é …ç›® | ç¢ºèªãƒã‚¤ãƒ³ãƒˆ |
|------|-------------|
| ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º | ã‚¿ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒååˆ†ãªå¤§ãã• |
| ã‚³ãƒãƒ³ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆ | çµµæ–‡å­—ãŒæ­£ã—ãè¡¨ç¤º |
| ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« | ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« |
| å…¥åŠ› | ã‚½ãƒ•ãƒˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨ã®å¹²æ¸‰ãªã— |

---

## ä»˜éŒ²: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

### `package.json`

```json
{
  "name": "obsidian-page-zettel",
  "version": "0.1.0",
  "description": "Daily note-based Zettelkasten workflow for Obsidian",
  "main": "main.js",
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "build": "node esbuild.config.mjs production",
    "lint": "eslint src/",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@types/node": "^16.11.6",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "esbuild": "^0.17.0",
    "eslint": "^8.0.0",
    "obsidian": "latest",
    "typescript": "^5.0.0"
  }
}
```

### `tsconfig.json`

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "inlineSourceMap": true,
    "inlineSources": true,
    "module": "ESNext",
    "target": "ES6",
    "allowJs": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "isolatedModules": true,
    "strictNullChecks": true,
    "lib": ["DOM", "ES5", "ES6", "ES7"]
  },
  "include": ["src/**/*.ts"]
}
```

### `manifest.json`

```json
{
  "id": "obsidian-page-zettel",
  "name": "Page Zettel",
  "version": "0.1.0",
  "minAppVersion": "1.0.0",
  "description": "Daily note-based Zettelkasten workflow",
  "author": "Your Name",
  "authorUrl": "",
  "isDesktopOnly": false
}
```

### `esbuild.config.mjs`

```javascript
import esbuild from "esbuild";
import process from "process";

const prod = process.argv[2] === "production";

esbuild.build({
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: ["obsidian"],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "main.js",
  watch: !prod,
}).catch(() => process.exit(1));
```

### `styles.css`

```css
/* ================================================
   Page Zettel - Mobile-First Styles
   ================================================ */

/* ãƒ¢ãƒ¼ãƒ€ãƒ«åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
.page-zettel-modal {
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

/* ãƒãƒ¼ãƒˆã‚¿ã‚¤ãƒ—é¸æŠã‚ªãƒ—ã‚·ãƒ§ãƒ³ */
.page-zettel-type-option {
  padding: 12px 16px;
  min-height: 48px;
  display: flex;
  align-items: center;
}

.page-zettel-type-container {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
}

.page-zettel-type-icon {
  font-size: 1.5em;
  flex-shrink: 0;
}

.page-zettel-type-text {
  flex: 1;
}

.page-zettel-type-label {
  font-weight: 600;
  font-size: 1em;
}

.page-zettel-type-description {
  color: var(--text-muted);
  font-size: 0.85em;
  margin-top: 2px;
}

/* Structure ææ¡ˆãƒ¢ãƒ¼ãƒ€ãƒ« */
.page-zettel-structure-option {
  padding: 12px 16px;
  min-height: 48px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.page-zettel-skip-option {
  color: var(--text-muted);
  font-style: italic;
}

/* å­¤ç«‹ãƒãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼ */
.page-zettel-orphan-view {
  padding: 16px;
}

.page-zettel-orphan-header {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.page-zettel-orphan-header h4 {
  margin: 0;
  flex: 1;
}

.page-zettel-orphan-stats {
  color: var(--text-muted);
  font-size: 0.9em;
}

.page-zettel-refresh-btn {
  background: transparent;
  border: none;
  cursor: pointer;
  font-size: 1.2em;
  padding: 8px;
  border-radius: 4px;
}

.page-zettel-refresh-btn:hover {
  background: var(--background-modifier-hover);
}

.page-zettel-orphan-empty {
  color: var(--text-success);
  padding: 24px;
  text-align: center;
  background: var(--background-secondary);
  border-radius: 8px;
}

.page-zettel-orphan-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.page-zettel-orphan-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid var(--background-modifier-border);
  gap: 12px;
}

.page-zettel-orphan-link {
  flex: 1;
  color: var(--text-accent);
  text-decoration: none;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.page-zettel-orphan-link:hover {
  text-decoration: underline;
}

.page-zettel-orphan-actions {
  flex-shrink: 0;
}

.page-zettel-action-btn {
  min-width: 44px;
  min-height: 44px;
  padding: 8px 16px;
  border-radius: 4px;
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  border: none;
  cursor: pointer;
  font-size: 0.9em;
}

.page-zettel-action-btn:hover {
  background: var(--interactive-accent-hover);
}

.page-zettel-action-btn:active {
  transform: scale(0.98);
}

/* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
@media (max-width: 600px) {
  .page-zettel-orphan-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .page-zettel-orphan-actions {
    width: 100%;
  }

  .page-zettel-action-btn {
    width: 100%;
  }
}
```

---

## ä»˜éŒ²: main.tsï¼ˆã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆï¼‰

```typescript
import { Plugin, TFile } from 'obsidian';
import { PageZettelSettings } from './types/settings';
import { DEFAULT_SETTINGS } from './settings/defaults';
import { PageZettelSettingsTab } from './settings/SettingsTab';
import { NoteManager } from './core/NoteManager';
import { FrontmatterService } from './core/FrontmatterService';
import { ConnectionManager } from './core/ConnectionManager';
import { registerCommands } from './commands';
import { OrphanView, VIEW_TYPE_ORPHAN } from './ui/views/OrphanView';
import { StructureSuggestModal } from './ui/modals/StructureSuggestModal';

export default class PageZettelPlugin extends Plugin {
  settings: PageZettelSettings;
  noteManager: NoteManager;
  frontmatterService: FrontmatterService;
  connectionManager: ConnectionManager;

  async onload(): Promise<void> {
    // è¨­å®šèª­ã¿è¾¼ã¿
    await this.loadSettings();

    // ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
    this.frontmatterService = new FrontmatterService(this.app);
    this.noteManager = new NoteManager(this.app, this.settings);
    this.connectionManager = new ConnectionManager(this.app);

    // ã‚³ãƒãƒ³ãƒ‰ç™»éŒ²
    registerCommands(this, this.settings);

    // ãƒ“ãƒ¥ãƒ¼ç™»éŒ²
    this.registerView(
      VIEW_TYPE_ORPHAN,
      (leaf) => new OrphanView(leaf, this)
    );

    // ãƒªãƒœãƒ³ã‚¢ã‚¤ã‚³ãƒ³
    this.addRibbonIcon('brain', 'Page Zettel', () => {
      this.showOrphanView();
    });

    // è¨­å®šã‚¿ãƒ–
    this.addSettingTab(new PageZettelSettingsTab(this.app, this));

    console.log('Page Zettel plugin loaded');
  }

  onunload(): void {
    console.log('Page Zettel plugin unloaded');
  }

  async loadSettings(): Promise<void> {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings(): Promise<void> {
    await this.saveData(this.settings);
  }

  /**
   * å­¤ç«‹ãƒãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
   */
  async showOrphanView(): Promise<void> {
    const existing = this.app.workspace.getLeavesOfType(VIEW_TYPE_ORPHAN);

    if (existing.length) {
      this.app.workspace.revealLeaf(existing[0]);
      return;
    }

    await this.app.workspace.getRightLeaf(false)?.setViewState({
      type: VIEW_TYPE_ORPHAN,
      active: true,
    });
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ Structure Note ã«æ¥ç¶š
   */
  async linkToStructure(file: TFile): Promise<void> {
    const modal = new StructureSuggestModal(
      this.app,
      this.settings,
      file,
      async (structureFile) => {
        if (structureFile) {
          await this.connectionManager.linkPermanentToStructure(file, structureFile);
        }
      }
    );
    modal.open();
  }
}
```
